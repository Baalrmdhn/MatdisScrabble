extends Node

var accepted_words = []
var previous_board := {}

func _ready():
	load_word_list()

func get_previous_board() -> Dictionary:
	return previous_board

func are_new_tiles_connected(new_tiles: Dictionary) -> bool:
	if new_tiles.size() == 0:
		return false
	
	var visited := {}
	var to_visit := [new_tiles.keys()[0]]  # Start from the first new tile

	while to_visit.size() > 0:
		var pos = to_visit.pop_back()
		if pos in visited:
			continue
		visited[pos] = true

		# Check for neighboring positions in all 4 directions (up, down, left, right)
		for dir in [Vector2(0, 1), Vector2(1, 0), Vector2(0, -1), Vector2(-1, 0)]:
			var neighbor = pos + dir

			# If the neighbor is already in the new tiles or the board, add it to the visit list
			if new_tiles.has(neighbor) or Global.board.has(neighbor):
				to_visit.append(neighbor)

	# Check if the number of visited new tiles equals the number of new tiles placed
	return visited.size() == new_tiles.size()




func load_word_list():
	var file = FileAccess.open("res://accepted_words.txt", FileAccess.READ)
	while not file.eof_reached():
		var word = file.get_line().strip_edges().to_upper()
		if word != "":
			accepted_words.append(word)
	file.close()

func is_connected_to_existing(board: Dictionary, new_tiles: Dictionary) -> bool:
	# Check if any new tile connects to an existing tile
	for pos in new_tiles.keys():
		for dir in [Vector2(0, 1), Vector2(1, 0), Vector2(0, -1), Vector2(-1, 0)]:
			var neighbor = pos + dir
			if board.has(neighbor) and not new_tiles.has(neighbor):
				return true  # Found a connection to an existing tile
	return false


func find_slot_by_pos(pos: Vector2) -> Node:
	var tile_slots := get_tree().get_nodes_in_group("tile_slots")
	for slot in tile_slots:
		if slot.row == pos.x and slot.col == pos.y:
			return slot
	return null


func _on_submit_pressed():
	var board := {}
	var tile_slots := get_tree().get_nodes_in_group("tile_slots")

	for slot in tile_slots:
		if slot.is_occupied():
			var letter = slot.occupied_tile.letter
			var pos = Vector2(slot.row, slot.col)
			board[pos] = letter

	# Get only the new tiles placed this turn
	var current_move := {}
	for pos in board.keys():
		if not get_previous_board().has(pos):
			current_move[pos] = board[pos]


	if current_move.size() == 0:
		print("❌ No new tiles placed.")
		return
		
	# Ensure all new tiles are placed in one connected line
	if not are_new_tiles_connected(current_move):
		print("❌ All new tiles must be connected in one group.")
		return

	# First move must include center tile
	if Global.is_first_move:
		if not current_move.has(Vector2(7, 7)):
			print("❌ First move must cover the center tile (H8).")
			return
	else:
		if not is_connected_to_existing(board, current_move):
			print("❌ New tiles must connect to existing tiles.")
			return

	var words = []
	words += find_words(board, true)  # horizontal
	words += find_words(board, false) # vertical

	if words.size() == 0:
		print("⚠️ No complete words found. Add more tiles.")
		return

	var invalid_words := []
	for word in words:
		if word not in accepted_words:
			invalid_words.append(word)

	if invalid_words.size() > 0:
		print("❌ Invalid words found: ", invalid_words)
	else:
		print("✅ All words are valid!")
		Global.is_first_move = false  # Only now toggle the flag
		previous_board = board.duplicate()
		# Remove played tiles from hand only after a valid move
		for pos in current_move.keys():
			var slot = find_slot_by_pos(pos)
			if slot and slot.is_occupied():
				var tile = slot.occupied_tile
				tile.lock()  # ← lock tile so it can't be moved again
				Global.player_hand.erase(tile)




func find_words(board: Dictionary, horizontal: bool) -> Array:
	var found_words = []
	var checked := {}

	for pos in board.keys():
		if pos in checked:
			continue

		var word = ""
		var letters = []
		var start_pos = pos
		var dir = Vector2(0, 1) if horizontal else Vector2(1, 0)

		# Backtrack to the start of the word
		var p = pos
		while board.has(p - dir):
			p -= dir
		start_pos = p

		# Go forward to build the word
		while board.has(p):
			letters.append(board[p])
			checked[p] = true
			p += dir

		if letters.size() > 1:
			word = "".join(letters)
			found_words.append(word)

	return found_words
